<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Problema da Galeria de Arte</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        header{
            background-color: #c594f2;
            color: white;
            padding: 1rem 0;
            text-align: center;
        }

        main {
           max-width : 800px;
           margin: 2rem auto;
           padding: 1rem;
           background: white;
           box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        footer {
            text-align: center;
            padding: 1rem;
            background-color: #c594f2;
            color: white;
        }

        .mycontainer {
            display: flex; /* Use flexbox for side-by-side layout */
            align-items: center; /* Center items vertically */
            width: 100%;
            margin: 10px;
        }



        .controls-column {
            margin-left: 10px; /* Space between SVG and controls */
            overflow-wrap: break-word;
        }

        .button {
            color: black; /* Text color */
            background-color: white; /* Button background */
            border: 1px solid black; /* Button border */
            padding: 5px 5px; /* Button padding */
            margin: 5px; /* Space between buttons */
            cursor: pointer; /* Pointer cursor on hover */
            font-size: 24px; /* Font size */
            border-radius: 5px; /* Rounded corners */
            transition: background-color 0.3s; /* Smooth background transition */
        }

        .button:hover {
            background-color: #f0f0f0; /* Light gray on hover */
        }

        #svgelem0 {
            border: 1px solid #ccc;
            background: lightyellow;
        }

        #svgelem1 {
            border: 1px solid #ccc;
            background: lightyellow;
        }

        .polygon {
            fill: #c594f2;
            stroke: black;
            stroke-width: 2;
            stroke-opacity: 1;
            fill-opacity: 1;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .highlight_polygon {
            fill: #a335de;
            fill-opacity: 0.5;
        }

        .black_point {
            fill: black;
            stroke: none;
            r: 4;
        }

        .blue_point {
            fill: #edec77;
            stroke: black;
            r: 4;
        }

        .red_point {
            fill: #eb445d;
            stroke: black;
            r: 4;
        }

        .green_point {
            fill: #65f077;
            stroke: black;
            r: 4;
        }

        .line_style {
            stroke-width: 2;
            stroke: red;
        }

        .edge_style {
            stroke-width: 1;
            stroke: black;
        }

        .small-text {
            font-size: 15px; /* Ajuste o valor conforme necessário */
        }

        .bold{
            color:#393839;
            font-weight: bold;
        }
    </style>
    <script>
        var numberFrames0 = 127;
        var currentIndex0 = 0;
        var intervalId0;
        var speed0 = 500;

        function fetchSVGContent0(file, callback) {
            fetch(file)
                .then(response => response.text())
                .then(data => callback(data))
                .catch(error => console.error('Error fetching SVG:', error));
        }

        function getLineFromFile0(fileUrl, lineNumber, callback) {
        fetch(fileUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.text();
            })
            .then(data => {
                const lines = data.split('\n');
                if (lineNumber < 0 || lineNumber >= lines.length) {
                    console.error('Line number out of range');
                    return;
                }
                callback(lines[lineNumber]); // Use callback to return the line
            })
            .catch(error => console.error('Error fetching file:', error));
        }

        function displayPolygon0() {
            var filename = `./animation0/frame${currentIndex0}.svg`;

            fetchSVGContent0(filename, function(svgContent) {
                var svg = document.getElementById('svgelem0');
                svg.innerHTML = svgContent;
            });

            getLineFromFile0('./animation0/text.txt', currentIndex0, function(line) {
                var spanElement = document.getElementById('spanelem0');
                spanElement.textContent = line; // Update span text
            });
        }

        function nextPolygon0() {
            if(intervalId0 && currentIndex0 == numberFrames0-1) {
                stopAutoPlay0();
            }
            else{
                currentIndex0 = (currentIndex0 + 1) % numberFrames0;
                displayPolygon0();
            }
        }

        function previousPolygon0() {
            currentIndex0 = (currentIndex0 - 1 + numberFrames0) % numberFrames0;
            displayPolygon0();
        }

        function startAutoPlay0() {
            if (!intervalId0) {
                intervalId0 = setInterval(nextPolygon0, speed0);
            }
        }

        function stopAutoPlay0() {
            if (intervalId0) {
                clearInterval(intervalId0);
                intervalId0 = null;
            }
        }

        function end0() {
            stopAutoPlay0();
            currentIndex0 = numberFrames0 - 1;
            displayPolygon0();
        }

        function reset0() {
            stopAutoPlay0();
            currentIndex0 = 0;
            displayPolygon0();
        }

        function changeSpeed0(newSpeed) {
            if (intervalId0) {
                stopAutoPlay0();
                speed0 = newSpeed;
                startAutoPlay0();
            }
            else{
                speed0 = newSpeed;
            }
            var speedCounter0 = document.getElementById("speedValue0");
            speedCounter0.innerText = speed0;
        }

        // displayPolygon0();
        window.onload = displayPolygon0;

        var numberFrames1 = 36;
        var currentIndex1 = 0;
        var intervalId1;
        var speed1 = 500;

        function fetchSVGContent1(file, callback) {
            fetch(file)
                .then(response => response.text())
                .then(data => callback(data))
                .catch(error => console.error('Error fetching SVG:', error));
        }

        function getLineFromFile1(fileUrl, lineNumber, callback) {
        fetch(fileUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.text();
            })
            .then(data => {
                const lines = data.split('\n');
                if (lineNumber < 0 || lineNumber >= lines.length) {
                    console.error('Line number out of range');
                    return;
                }
                callback(lines[lineNumber]); // Use callback to return the line
            })
            .catch(error => console.error('Error fetching file:', error));
        }

        function displayPolygon1() {
            var filename = `./animation1/frame${currentIndex1}.svg`;

            fetchSVGContent1(filename, function(svgContent) {
                var svg = document.getElementById('svgelem1');
                svg.innerHTML = svgContent;

            });

            getLineFromFile1('./animation1/text.txt', currentIndex1, function(line) {
                var spanElement = document.getElementById('spanelem1');
                spanElement.textContent = line; // Update span text
            });
        }

        function nextPolygon1() {
            if(intervalId1 && currentIndex1 == numberFrames1-1) {
                stopAutoPlay1();
            }
            else{
                currentIndex1 = (currentIndex1 + 1) % numberFrames1;
                displayPolygon1();
            }
        }

        function previousPolygon1() {
            currentIndex1 = (currentIndex1 - 1 + numberFrames1) % numberFrames1;
            displayPolygon1();
        }

        function startAutoPlay1() {
            if (!intervalId1) {
                intervalId1 = setInterval(nextPolygon1, speed1);
            }
        }

        function stopAutoPlay1() {
            if (intervalId1) {
                clearInterval(intervalId1);
                intervalId1 = null;
            }
        }

        function end1() {
            stopAutoPlay1();
            currentIndex1 = numberFrames1 - 1;
            displayPolygon1();
        }

        function reset1() {
            stopAutoPlay1();
            currentIndex1 = 0;
            displayPolygon1();
        }

        function changeSpeed1(newSpeed) {
            if (intervalId1) {
                stopAutoPlay1();
                speed1 = newSpeed;
                startAutoPlay1();
            }
            else{
                speed1 = newSpeed;
            }
            var speedCounter1 = document.getElementById("speedValue1");
            speedCounter1.innerText = speed1;
        }

        displayPolygon1();

    </script>
</head>
<body>
    <header>
        <h1>Problema da Galeria de Arte</h1>
    </header>

    <main>
        <h2>Problema da Galeria de Artes</h2>
        <p> Imagine que você é dono de uma galeria de artes muito famosa em sua cidade e que,
            devido a tal fama, sua propriedade acaba sendo alvo de inúmeros assaltos. Você, em busca
            de uma solução, pensou em instalar câmeras de forma a cobrir toda área da galeria, mas
            não sabe ao certo quantas câmeras deve comprar para que seu investimento seja o mínimo
            possível, mas ainda sim não deixe nenhum canto de sua propriedade sem cobertura.
        </p>

        <p>
            Bem, se algum dia você passou por esse cenário, ou talvez, por um parecido, parabéns! Você
            se deparou com o famoso <span class="bold">"Problema da Galeria de Artes"</span>! Mas, para a sua infelicidade, trago más
            notícias: esse problema não apenas aparenta ser complexo: ele é de fato muito complexo. Ele é tão
            complexo que faz parte de uma classe de complexidade denominada "NP-dificuldade". Isso significa que
            caso você queira montar um programa no computador que te responda a quantidade de câmeras ótima
            que você deve comprar, você não conseguirá fazer isso em tempo polinomial, ou seja, dependendo
            do tamanho da sua galeria, essa resposta pode demorar muito tempo para ser computada...
        </p>
        <p>
            Mas não se preocupe! Aqui nesse site te mostraremos um algoritmo bem mais simples e rápido que te dará
            uma resposta boa para seu problema. Talvez não seja a melhor resposta, mas ela é boa o suficiente e não te
            custará muito...
        </p>

        <h3 style="margin-bottom: 1px;">Triangulação de polígonos</h3>
        <p>
        Nós resolveremos o seu problema com uma simples observação: sua galeria de artes pode ser representada como um
        polígono, certo? E se você reparar bem, um polígono pode ser dividido em diversos triângulos menores. Então a ideia é posicionar as
        câmeras em pontos estratégicos nesses triângulos internos, de forma a fazer com que uma câmera cubra muitos triângulos de uma só vez.
        </p>
        <p> Para ilustrar, imagine que sua sala seja o polígono abaixo. A animação mostrará como podemos dividi-la em triângulos menores. Basta você clicar
            no botão do meio, <span class="bold">"AutoPlay"</span>, e ajustar a frequência na barra abaixo como quiser.
        </p>

        <div class="mycontainer">
            <div class="svg-column">
                <svg id="svgelem0" width="450" height="450" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 600"></svg>
            </div>

            <div class="controls-column">
                <div style="flex:1; height: 50px;">
                    <span id="spanelem0">No text yet</span>
                </div>
                <br>
                <button class="button" onclick="previousPolygon0()"><span class="material-icons">fast_rewind</span></button>
                <button class="button" onclick="nextPolygon0()"><span class="material-icons">fast_forward</span></button>
                <button class="button" onclick="startAutoPlay0()"><span class="material-icons">play_arrow</span></button>
                <button class="button" onclick="stopAutoPlay0()"><span class="material-icons">pause</span></button>
                <button class="button" onclick="reset0()"><span class="material-icons">skip_previous</span></button>
                <button class="button" onclick="end0()"><span class="material-icons">skip_next</span></button>
                <br>
                <label for="speedRange0" class="small-text">Frequência do reprodutor: 
                    <span id="speedValue0" class="small-text">500</span> ms
                </label>
                <br>
                <input type="range" id="speedRange0" min="100" max="1000" value="500" step="100" oninput="changeSpeed0(this.value)" style="width: 300px;">
            </div>
        </div>

        <p> Fazer essa triangulação não é tão difícil. Utilizamos um método chamado 'corte de orelhas', onde examinamos cada vértice para determinar se ele é, ou não, uma 'orelha'. 
            Um vértice orelha deve ser convexo e, junto com seus vizinhos, formar um triângulo que não inclua outros vértices internamente.
        </p>
        <p> Você pode acompanhar isso sendo feito frame a frame na animação com os botões no canto esquerdo, <span class="bold">"Previous"</span> e <span class="bold">"Next"</span>. Para ver o início ou o fim do algoritmo, clique nos botões no canto direito
            <span class="bold">"Begin"</span> e <span class="bold">"End"</span>.  Analise o passo a passo detalhadamente e perceba que para cada vértice, simulamos qual seria o triângulo formado por ele e seus vizinhos. Caso o vértice seja uma orelha, ele é marcado de verde, 
            caso contrário, ele permanece preto.
        </p>
        <p> Perceba que após passar por todos os vértices, começamos a remover as orelhas, mantendo apenas um cuidado: quando uma orelha é removida, o status de seus vizinhos
            pode mudar, isto é, eles podem se tornar orelhas ou deixarem de ser, portanto, devemos atualizá-los.
        </p>

        <h3> Coloração dos vértices</h3>
        <p> Agora que temos uma triangulação, vamos colorir os vértices do nosso polígono da seguinte maneira:
        </p>
        <p> Escolhemos um triângulo inicial e colorimos todos os seus vértices de cores diferentes. Depois, colorimos os vértices dos triângulos adjacentes. Mas perceba: um triângulo é
            adjacente a outro se somente se eles possuem dois vértices em comum. Portanto, ao olhar para um triângulo adjcente, apenas um vértice dele não estará colorido e, por isso,
            teremos apenas uma escolha de cor possível para atribuí-lo.
        </p>

        <div class="mycontainer">
            <div class="svg-column">
                <svg id="svgelem1" width="450" height="450" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 600"></svg>
            </div>

            <div class="controls-column">
                <div style="flex:1; height: 50px;">
                    <span id="spanelem1">No text yet</span>
                </div>
                <br>
                <button class="button" onclick="previousPolygon1()"><span class="material-icons">fast_rewind</span></button>
                <button class="button" onclick="nextPolygon1()"><span class="material-icons">fast_forward</span></button>
                <button class="button" onclick="startAutoPlay1()"><span class="material-icons">play_arrow</span></button>
                <button class="button" onclick="stopAutoPlay1()"><span class="material-icons">pause</span></button>
                <button class="button" onclick="reset1()"><span class="material-icons">skip_previous</span></button>
                <button class="button" onclick="end1()"><span class="material-icons">skip_next</span></button>
                <br>
                <label for="speedRange1" class="small-text">Frequência do reprodutor: 
                    <span id="speedValue1" class="small-text">500</span> ms
                </label>
                <br>
                <input type="range" id="speedRange1" min="100" max="1000" value="500" step="100" oninput="changeSpeed1(this.value)" style="width: 300px;">
            </div>
        </div>

        <h3>
            Custo final
        </h3>
        <p>
            Perceba que escolhendo apenas um conjunto de vértices de mesma cor, conseguimos posicionar as câmeras e cobrir toda área do polígono. E, como a partir desse algoritmo sempre conseguimos
            encontrar uma 3-coloração, é possível garantir que o gasto máximo em câmeras é um terço da quantidade inicial de vértices da sala, não importa seu formato! Que incrível! Com isso, mostramos que,
            apesar do problema ser difícil, é possível achar soluções talvez não ótimas, mas boas o suficiente para serem aplicadas.
        </p>

    </main>
</body>
</html>
